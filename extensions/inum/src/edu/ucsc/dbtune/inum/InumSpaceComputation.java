package edu.ucsc.dbtune.inum;

import java.sql.SQLException;
import java.util.Set;

import edu.ucsc.dbtune.metadata.Catalog;
import edu.ucsc.dbtune.optimizer.Optimizer;
import edu.ucsc.dbtune.optimizer.plan.InumPlan;
import edu.ucsc.dbtune.util.Environment;
import edu.ucsc.dbtune.workload.SQLStatement;

import static edu.ucsc.dbtune.util.EnvironmentProperties.INUM_EAGER_COMPUTATION;
import static edu.ucsc.dbtune.util.EnvironmentProperties.INUM_IBG_COMPUTATION;

/**
 * Computes set of optimal plans that need to be cached for a given statement in order to be able to 
 * answer what-if calls efficiently and without the need of contacting the optimizer again.
 * <p>
 * For statements containing a large number of joins, for instance for queries joining 10 or 20 
 * tables, the computation of the INUM space becomes expensive, as more than a thousand optimizer 
 * calls are required to fully compute the INUM Space.
 * <p>
 * Fortunately, there are ways to optimize the performance of INUM construction by abstracting this 
 * mechanism and enable different implementations, so that it's still efficient to do what-if 
 * analysis on INUM. Alternatives to this can range from <i>Eager evaluation</i> to others more 
 * sophisticated techniques such as the ones outlined in [1], like <i>Lazy</i> or <i>cost-based 
 * evaluation</i>.
 *
 * @author Ivo Jimenez
 * @see <a href="http://portal.acm.org/citation.cfm?id=1325974"?>
 *        [1] Efficient use of the query optimizer for automated physical design
 *      </a>
 */
public interface InumSpaceComputation
{
    /**
     * Invokes the optimizer in order to reveal the set of optimal plans that need to be cached for 
     * the given statement.
     * <p>
     * The optimizer should be able to produce plans, i.e. the {@link 
     * edu.ucsc.dbtune.optimizer.ExplainedSQLStatement} objects that get generated by it should 
     * return a non-null instance when calling {@link 
     * edu.ucsc.dbtune.optimizer.ExplainedSQLStatement#getPlan}.
     * 
     * @param space
     *      the space to be computed. {@link Set#clear} is invoked before populating it.
     * @param statement
     *      SQL statement for which the INUM space is computed
     * @param delegate
     *      optimizer used to execute {@link Optimizer#explain(SQLStatement, Configuration) what if 
     *      calls}
     * @param catalog
     *      used to retrieve metadata for objects referenced in the statement
     * @throws SQLException
     *      if the inum space can't be populated
     */
    void compute(Set<InumPlan> space, SQLStatement statement, Optimizer delegate, Catalog catalog)
        throws SQLException;

    /**
     */
    public abstract class Factory
    {
        /**
         * utility class.
         */
        private Factory()
        {
        }

        /**
         * Creates a computation.
         *
         * @param env
         *      used to access the type of computation to instantiate.
         * @return
         *      a new space computation
         * @throws InstantiationException
         *      if throws an exception
         */
        public static InumSpaceComputation newInumSpaceComputation(Environment env)
            throws InstantiationException
        {
            if (env.getInumSpaceComputation().equals(INUM_EAGER_COMPUTATION))
                return new EagerSpaceComputation();
            else if (env.getInumSpaceComputation().equals(INUM_IBG_COMPUTATION))
                return new IBGSpaceComputation();

            throw new InstantiationException(
                    "Unknown space computation option " + env.getInumSpaceComputation());
        }
    }
}
